一 DBMS（数据库管理系统）存储引擎
1 主要存储引擎
Myslam;  Innodb; memory; archive; Federated

2 Innodb与Myslam的区别
1. InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；
2. InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；
3. InnoDB的主键是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引是非聚集性索引，叶子节点存放主键的值，需要两次查询，先通过辅助索引查询到主键值，然后再通过主键索引查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。


4. InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）；
   innodb不要这个是因为事务的特性，同一时刻对不同事务来说，表的行数可能不一样，innodbcount或同级本事务统计的行数。
5. MyISAM表格可以被压缩后进行查询操作
6. InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁
7. InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有
8. Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI
   Innodb：frm是表定义文件，ibd是数据文件
   Myisam：frm是表定义文件，myd是数据文件，myi是索引文件
   MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。
   二 索引
   https://blog.csdn.net/qq_35190492/article/details/109257302?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167955801216800226590235%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167955801216800226590235&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-109257302-null-null.142^v76^insert_down38,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=mysql%E7%9A%84%E7%B4%A2%E5%BC%95&spm=1018.2226.3001.4187
   索引是帮助mysql该校获取数据的数据结构，是加快检索表中数据的方法。
   mysql有四种不同的索引：主键索引、唯一索引、普通索引、联合索引
   优点：加快检索效率，对数据进行排序
   缺点： 降低了插入删除修改等更新表的效率，因为需要花费时间维护索引；需要占物理和数据空间
   常见索引原则

1 索引类型
● 主键索引
索引列中的值必须是唯一的，不允许有空值，是一种约束，可以作为其他表的外键，一个表只能有一个主键；
● 普通索引
MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。
● 唯一索引
索引列中的值必须是唯一的，但是允许为空值。
● 全文索引
只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引。字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引。 MyISAM和InnoDB中都可以使用全文索引。
● 空间索引
MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。MySQL在空间索引这方面遵循OpenGIS几何数据模型规则。
● 前缀索引
在文本类型如CHAR,VARCHAR,TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定。
● 其他（按照索引列数量分类）
1. 单列索引
2. 组合索引组合索引的使用，需要遵循最左前缀匹配原则（最左匹配原则）。一般情况下在条件允许的情况下使用组合索引替代多个单列索引使用。
   最左前缀匹配原则：MySQL 建立联合索引的规则是这样的，它会首先根据联合索引中最左边的、也就是第一个字段进行排序，在第一个字段排序的基础上，再对联合索引中后面的第二个字段进行排序，依此类推。
   ○ 对于联合索引，MySQL 会一直向右匹配直到遇到范围查询（> ， < ，between，like）就停止匹配。比如 a = 3 and b = 4 and c > 5 and d = 6，如果建立的是（a,b,c,d）这种顺序的索引，那么 d 是用不到索引的，但是如果建立的是 （a,b,d,c）这种顺序的索引的话，那么就没问题，而且 a，b，d 的顺序可以随意调换。
   ○ = 和 in 可以乱序，比如 a = 3 and b = 4 and c = 5 建立 （a，b，c）索引可以任意顺序。
   ○ 如果建立的索引顺序是 （a，b）那么直接采用 where b = 5 这种查询条件是无法利用到索引的，这一条最能体现最左匹配的特性。
   ○ B+树会先比较a列来确定下一步应该搜索的方向，往左还是往右。如果a列相同再比较b列。但是如果查询条件没有a列，B+树就不知道第一步应该从哪个节点查起。所以需要最左匹配原则
   ● 覆盖索引
   覆盖索引值一个索引包含(或覆盖)所有需要查询的字段值,为了不回表
   常见的方法是将被查询的字段，建立到联合索引里去；
   覆盖索引并不是说是索引结构，覆盖索引是一种很常用的优化手段。因为在使用辅助索引的时候，我们只可以拿到主键值，相当于获取数据还需要再根据主键查询主键索引再获取到数据。但是试想下这么一种情况，在上面abc_innodb表中的组合索引查询时，如果我只需要abc字段的，那是不是意味着我们查询到组合索引的叶子节点就可以直接返回了，而不需要回表。这种情况就是覆盖索引。

● 联合索引的使用
联合索引，在建立索引的时候，尽量在多个单列索引上判断下是否可以使用联合索引。联合索引的使用不仅可以节省空间，还可以更容易的使用到索引覆盖。试想一下，索引的字段越多，是不是更容易满足查询需要返回的数据呢。比如联合索引（a_b_c），是不是等于有了索引：a，a_b，a_b_c三个索引，这样是不是节省了空间，当然节省的空间并不是三倍于（a，a_b，a_b_c）三个索引，因为索引树的数据没变，但是索引data字段的数据确实真实的节省了。
● 联合索引的创建原则，在创建联合索引的时候因该把频繁使用的列、区分度高的列放在前面，频繁使用代表索引利用率高，区分度高代表筛选粒度大，这些都是在索引创建的需要考虑到的优化场景，也可以在常需要作为查询返回的字段上增加到联合索引中，如果在联合索引上增加一个字段而使用到了覆盖索引，那我建议这种情况下使用联合索引。
● 联合索引的使用
考虑当前是否已经存在多个可以合并的单列索引，如果有，那么将当前多个单列索引创建为一个联合索引。
当前索引存在频繁使用作为返回字段的列，这个时候就可以考虑当前列是否可以加入到当前已经存在索引上，使其查询语句可以使用到覆盖索引。

2 索引的数据结构
包括聚集索引、覆盖索引、组合索引、前缀索引、唯一索引等，没有特别说明，默认都是使用B+树结构组织（多路搜索树，并不一定是二叉的）的索引。
2.1 B树
B树是一种多叉平衡查找树，如图有一下特点：
1. B树的节点中存储着多个元素，每个内节点有多个分叉。
2. 节点中的元素包含键值和数据，节点中的键值从大到小排列。也就是说，在所有的节点都储存数据。
3. 父节点当中的元素不会出现在子节点中。
4. 所有的叶子结点都位于同一层，叶节点具有相同的深度，叶节点之间没有指针连接。

缺点：
1. B树不支持范围查询的快速查找，你想想这么一个情况如果我们想要查找10和35之间的数据，查找到15之后，需要回到根节点重新遍历查找，需要从根节点进行多次遍历，查询效率有待提高。
2. 如果data存储的是行记录，行的大小随着列数的增多，所占空间会变大。这时，一个页中可存储的数据量就会变少，树相应就会变高，磁盘IO次数就会变大。
   2.2 B+树
   B+树，作为B树的升级版，在B树基础上，MySQL在B树的基础上继续改造，使用B+树构建索引。B+树和B树最主要的区别在于非叶子节点是否存储数据的问题
   ● B树：非叶子节点和叶子节点都会存储数据。
   ● B+树：只有叶子节点才会存储数据，非叶子节点至存储键值。叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。

B+树相较B树的优点：
● B树只适合随机检索，B+树支持随机检索和顺序检索(叶子节点存放全部数据且为双向链表);
● B+数空间利用率高，可减少IO次数(B+数内部节点没有只想关键字的指针);
● 查询了效率更加稳定
● 范围查询元素遍历简单
● 增删节点效率高(叶子节点为链表)
2.3 Hash
Hash Hash索引只能用于对等比较，例如=,<=>（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。

Hash在进行等值查询时比B+数快，但
● 不能进行范围查询
● hash索引不支持使用索引进行排序，原理同上。
● hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。
● hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。
● hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。


3 索引不生效的情况
1. 使用不等于条件查询，会全表扫描,is null走索引，is not null不走索引
2. or条件不走索引，但or条件都是同一个索引字段会走索引
3. in走索引，not in不走索引
4. 列参与了数学运算或者函数
5. 隐式转换不走索引
6. like模糊查询时，“XXX%”会走索引，“%XXX”不会走索引;
7. 当mysql分析全表扫描比走索引快时不适用索引
8. 使用联合索引时，碰到范围查询，后面的列不会再走索引，或者没有添加左边的列作为查询条件;
   三 事务
   1 事物的四大特性ACID
1. 原子性(Atomicity)：表示事务不可再分，是一个不可分割的逻辑单元，要么全部执行，要么都不执行
2. 一致性(Consistency)：事务完后时，数据必须处于一致状态.
   举个栗子，李二给王五转账50元，其事务就是让李二账户上减去50元，王五账户上加上50元；一致性是指其他事务看到的情况是要么李二还没有给王五转账的状态，要么王五已经成功接收到李二的50元转账。而对于李二少了50元，王五还没加上50元这个中间状态是不可见的。
3. 隔离性(Isoation)：事务之间的操作是互相隔离的，一个事务的执行不会被其他事务干扰
4. 持久性(Durability):事务对数据库的修改的永久有效的。
   2 事务并发时出现的问题
   假设存在两个事务A,B
1. 脏读:事务A读到了事务B修改但未提交的数据，导致事务A出现脏读
2. 丢失修改：事务A和事务B同时读取了一个数据，事务A先修改提交，事务B后修改提交，丢失了事务A的修改
3. 不可重复读：事务A先后读取一各数据，但中间被事务B修改了，导致两次读取数据不一样
4. 幻读：事务A先后读取一各数据，但中间被事务B修改了，导致两次读取数据不一样
   不可重复读和幻读的区别：不可重复读侧重读取的数据某些字段被修改，幻读侧重读取到的数据量不一样，比如多读了几条数据
   3 事务的隔离级别
1. 读未提交
2. 读已提交：Oracle默认隔离级别
3. 可重复读：
4. 序列化

innodb默认的隔离级别是可重复读,但使用的是Next-key Lock锁算法，因此可以避免幻读的产生；
在SERIALIABLE的事务隔离级别，InnoDB存储引擎会对每个SELECT语句后自动加上LOCK IN SHARE MODE，即为每个读取操作加一个共享锁。因此在这个事务隔离级别下，读占用了锁，对一致性的非锁定读不再予以支持。
innodb在 REPEATABLE READ 隔离级别下，InnoDB 通过 MVCC 避免了快照读中的幻读，通过 Next-Key Locks 避免了当前读中的幻读
Next-key Lock
间隙锁(gap锁,前开后开)和行锁合称Next-key Lock，Next-key Lock是前开后闭区间,即Next-key Lock锁住的是某段区间(无论是等值查询还是范围查询,所以不会有新行插入)
原则 1：加锁的基本单位是 next-key lock。next-key lock 是前开后闭区间。
原则 2：只有访问到的对象才会加锁。
优化 1：索引上的等值查询，
命中唯一索，退化为行锁。
命中普通索引，左右两边的GAP Lock + Record Lock。
优化 2：
索引上的等值查询，未命中，所在的Net-Key Lock，退化为GAP Lock 。
索引在范围查询：
1.等值和范围分开判断。
2.索引在范围查询的时候 都会访问到所在区间不满足条件的第一个值为止。
3.如果使用了倒叙排序，按照倒叙排序后，
检索范围的右边多加一个GAP。
哪个方向还有命中的等值判断，再向同方向拓展外开里闭的区间。





注意：刚才是mysql7.0版本所以范围查询锁定的区间是(10,15]。如果是8.0范围查询锁定的是(10,15)。区别在于范围查询加锁的时候7.0版本加的是next-key lock。8.0版本范围查询加锁加的是GAP Lock。


MVCC多版本并发控制
1. 什么是MVCC
   MVCC，全称 Multi-Version Concurrency Control ，即多版本并发控制。MVCC 是一种并发控制的方法，一种抽象概念，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存
   MVCC 在 MySQL InnoDB 中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读
   MVCC在Innodb中是通过在每行纪录后面保存两个隐藏的列来实现，这两个列保存了行的创建时间和过期时间，存储的不是真实时间，而是系统版本号。
2. 什么是当前读和快照读
   当前读
   像 select lock in share mode (共享锁), select for update; update; insert; delete (排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁
   快照读
   像不加锁的 select 操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即 MVCC ,可以认为 MVCC 是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本
3.  MVCC 就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现
4. 数据库并发场景有三种，分别为：
   ● 读-读：不存在任何问题，也不需要并发控制
   ● 读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读
   ● 写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失
   ● MVCC 带来的好处是？
   多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以 MVCC 可以为数据库解决以下问题
   ○ 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能(读写冲突不加锁)
   ○ 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题
5. 原理：基于undolog、版本链、readview实现
   ● 原子性：通过undolog实现。
   ● 持久性：通过redolog实现。
   ● 隔离性：通过加锁（当前读）&MVCC（快照读）实现。
   ● 一致性：通过undolog、redolog、隔离性共同实现。
6. mvcc如何实现RC和RR的隔离级别
   （1）RC（读已提交）的隔离级别下，每个快照读都会生成并获取最新的readview。
   （2）RR（可重复读）的隔离级别下，只有在同一个事务的第一个快照读才会创建readview，之后的每次快照读都使用的同一个readview，所以每次的查询结果都是一样的。
7. 幻读问题
   ● 快照读：通过mvcc，RR的隔离级别解决了幻读问题，因为每次使用的都是同一个readview。
   ● 当前读：通过next-key锁（行锁+gap锁），RR隔离级别并不能解决幻读问题。




4 分布式事务
4.1 概念
分布式事务指的是允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的ACID要求又有了提高.InnoDB存储引擎提供了对XA事务的支持，并通过XA事务来支持分布式事务的实现。另外，在使用分布式事务时，InnoDB存储引擎的事务隔离级别必须设置为SERIALIZABLE.
分布式事务使用两段式提交（two-phase commit）的方式。在第一阶段，所有参与全局事务的节点都开始准备（PREPARE），告诉事务管理器它们准备好提交了。在第二阶段，事务管理器告诉资源管理器执行ROLLBACK还是COMMIT。如果任何一个节点显示不能提交，则所有的节点都被告知需要回滚。
4.2 实现方式
4.2.1 基于mq实现分布式事务（适用高并发的场景）


4.2.2 基于XA协议实现分布式事务（适用并发量不高的场景，速度慢）
核心是一个事务管理器用来统一管理两个分布式数据库,主要利用了XA的二段式事务；

4.2.3 基于TCC协议机制实现分布式事务
TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应 的确认和补偿（撤销）操作。
它分为三个阶段：
1、Try 阶段主要是对业务系统做检测及资源预留
2、Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm 阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。
3、Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源 释放。
总结优缺点：
优点：相比两阶段提交，可以用性较强，
缺点：数据一致性要差一些，实现复杂高，需要些很多补充机制代码来实现，
而不足之处则在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现try、confirm、cancel三个操作。此外，其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。

四 锁
1 锁的类型
行级锁
行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。
特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
表级锁
表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。
特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。
页级锁
页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。
特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般
InnoDB存储引擎的锁的算法有三种
● Record lock：单个行记录上的锁
● Gap lock：间隙锁，锁定一个范围，不包括记录本身
● Next-key lock：record+gap 锁定一个范围，包含记录本身
2 死锁
死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。
常见的解决死锁的方法
1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。
2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；
3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；
4、设置超时时间，超时后自动释放；
3 数据库的悲观锁和乐观锁实现
悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制
乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现、redis可以用watch实现。

五 其他问题
1 三大范式
1. 第一范式（列不可再分)：确保每列的原子性，例如江苏省南京市可再分

2. 第二范式(每个表只描述一件事情):非主键列完全依赖主键,,价格依赖了非主键列产品编号

3. 第三范式(不存在对非主键列的传递依赖)，顾客姓名依赖顾客编号，顾客编号依赖订单编号，传递依赖

2 数据库优化

2.1 架构优化
常见的优化手段有：缓存，读写分离，分库分表等，每种优化手段又适用于不同的应用场景。
2.1.1 分布式缓存
在应用与数据库之间增加一个缓存服务，如Redis或Memcache。
2.1.2 读写分离
一主多从，读写分离，主动同步，是一种常见的数据库架构优化手段。
一般来说当你的应用是读多写少，数据库扛不住读压力的时候，采用读写分离，通过增加从库数量可以线性提升系统读性能。

2.1.3 分库分表
分库分表方案是对关系型数据库数据存储和访问机制的一种补充。
分库：将一个库的数据拆分到多个相同的库中，访问的时候访问一个库
分表：把一个表的数据放到多个表中，操作对应的某个表就行
垂直拆分：
优点：
1.拆分后业务清晰（专库专用按业务拆分）
2.数据维护简单，按业务不同，业务放到不同机器上
缺点:
1.如果单表的数据量大，写读压力大
2.受某种业务决定，或者被限制，也就是说一个业务往往会影响到数据库的瓶颈（性能问题，如双十一抢购）
3.部分业务无法关联join，只能通过java程序接口去调用，提高了开发复杂度
水平拆分：
优点：
1.单库/单表的数据保持在一定量（减少），有助于性能提高
2.提高了系统的稳定性和负载能力
3.拆分表的结构相同，程序改造较少。
缺点:
1.数据的扩容很有难度维护量大
2.拆分规则很难抽象出来
3.分片事务的一致性问题部分业务无法关联join，只能通过java程序接口去调用
分库分表带来的问题：
ⅰ. 分布式事务
ⅱ. 跨库join查询
ⅲ. 分布式全局唯一id
ⅳ. 开发成本 对程序员要求高







2.2  硬件优化
2.3 数据库表结构优化
● 选取合适的字段属性，整型>date,time>varchar,text,char>blob，同时设置字段为NOTNULL，这样数据库可以在查询的受不比较NULl值
● 合理使用索引
● 优化表关系
2.4 Sql优化
● 使用union all代替union，使用union代替临时表
● 使用join代替子查询
● 避免select*
● 减少like使用
● 不使用NOT IN和！=操作，避免全表扫描
● 避免在where中对null进行判断
● join字段建立索引
● 避免复杂的Sql语句，避免慢查询概率（慢查询通过查询慢查询日志 show variable like '%slow_query_log'）
● 避免order by rand()类似写法,rand()导致数据列被多次扫描
sql优化步骤：：
● 查看执行计划 explain sql
● 如果有告警信息，查看告警信息 show warnings;
● 查看SQL涉及的表结构和索引信息
● 根据执行计划，思考可能的优化点
● 按照可能的优化点执行表结构变更、增加索引、SQL改写等操作
● 查看优化后的执行时间和执行计划
● 如果优化效果不明显，重复第四步操作


3 数据库id相关问题
3.1 数据库id的选择
3.1.1 UUID
标准的UUID格式是(8-4-4-4-12),共36个字符.
优点：
● ①能够保证独立性，字符串类型对数值型也能兼容不重复，程序可以在不同的数据库间迁移
● ②保证生成的ID不仅是表独立的，而且是库独立的
● ③可以用32进制对原先进行缩小存放
缺点：
UUID占用内存空间大，每次生成的都是随机的串，增删改会导致索引B+树重建索引定位更慢，不易排序(常见缩短UUID长度的方式是(1.省略"-";2.扩大每位的进制数))
3.1.2 雪花算法
优点：
● ①自增Long型(趋势递增，递增但不连续)的ID，固定19位10进制(或者64位2进制)，耗费空间比UUID小，走索引速度更快，对于排序有更好的性能
● ②对同一公司的统一算法计量的设备能够唯一表示，对分布式是友好的，且对数据库索引是友好的
缺点：
● ①依赖于机器时钟，如果机器时钟回拨有可能出现重复ID。百度的生成器UidGenerator已经解决了；
● ②由于雪花算法生成的ID是19位数字，传递给前端会出现精度丢失(前端会接收一个17位有效数字的科学计数法数字)，解决方法就是专为JSON字符串传输
○ 解决方法一：通过配置将数字都序列化成字符串的配置解决雪花算法精度丢失
○ 解决方法二：使用配置类或者注解，改变序列化过程（加在pojo的ID字段上）
3.1.3 整型自增ID
优点：
● 自增Long类型的主键可以主键自增，数字类型占用空间小，走索引速度更快，对于排序有更好的性能
缺点：
● ①若需要手动插入，或者从其他系统导入带有ID的数据，这些数据的id和原来数据的id容易造成冲突，若其他系统的ID不是数值型的，则同步数据更加痛苦
● ②从1自增上去的ID，容易被猜测进行数据窃取等安全问题
● ③对分布式很不友好，即使用分段生成的ID(比如定义5千万后的ID给二数据库)也有可能之前一段的超额导致重复的问题；若是采用取余分布ID(3个数据库集群，就对三取余，相同余数的位于一个数据库)的策略，扩容后该如何对之前的数据进行处理又是难题。

3.2 数据库自增id用完了会怎样？
可以分为以下几种情况：
1. 有主键的情况：自增Id用完的情况一般为int类型主键，可以容纳2^32-1个数据，可以换成bigint类型2^64-1，如果自增id用完了会报主键冲突的错误；
2. 没有主键的情况：没有主键数据库会创建一个虚拟主键，最多可容纳2^48-1，超出范围则从0开始计数，会覆盖原有的的信息；
   3.3 InnoDB为什么推荐使用自增ID作为主键？
   答：自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。
   4 mysql有关权限的表
   ● user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。
   ● db权限表：记录各个帐号在各个数据库上的操作权限。
   ● table_priv权限表：记录数据表级的操作权限。
   ● columns_priv权限表：记录数据列级的操作权限。
   ● host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。


5 Mysql删除表的几种方式
1. delete:只删除表中数据，不删除表结构，支持条件过滤，支持回滚，记录日志，因此比较慢
2. truncate:仅删除所有数据，不删除表结构，不支持条件过滤，不支持回滚，不记录日志，效率比delete高；
3. drop：删除表结构和数据，将表所占空间全部释放，删除效率最高；
   6 视图
   6.1 概念
   视图是一种虚拟表，对图并不在数据库中实际存在
   6.2 对比普通表的优势
1. 简单：使用视图不需要考虑表结构以及表关系
2. 安全：使用视图的用户只能访问他们被允许查询的结果集，对视图的操作不会影响数据库表的数据
3. 数据独立，可以屏蔽表结构变化对用户的影响

7 MYSQL日志
7.1 redo log
redo log叫做重做日志，是保证事务持久性的重要机制。当mysql服务器意外崩溃或者宕机后，保证已经提交的事务，确定持久化到磁盘中的一种措施。

7.2 bin log
binlog是属于MySQL Server层面的，又称为归档日志，属于逻辑日志，是以二进制的形式记录的，用于记录数据库执行的写入性操作(不包括查询)信息，依靠binlog是没有crash-safe能力的在实际应用中，binlog的主要使用场景有两个，分别是主从复制和数据恢复。
1）、主从复制：在Master端开启binlog，然后将binlog发送到各个Slave端，Slave端重放binlog从而达到主从数据一致。
2）、 数据恢复：通过使用mysqlbinlog工具来恢复数据。
7.3 undo log
● undo log存在的意义是确保数据库事务的原子性。原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
● redo log记录了事务的行为，可以很好地保证一致性，对数据进行“重做”操作。但事务有时还需要进行“回滚”操作，这时就需要undo log。当我们对记录做了变更操作的时候就需要产生undo log，其中记录的是老版本的数据，当旧事务需要读取数据时，可以顺着undo链找到满足其可见性的记录。
● undo log通常以逻辑日志的形式存在。我们可以认为当delete一条记录时，undo log会产生一条对应的insert记录，反之亦然。当update一条记录时，会产生一条相反的update记录。
● undo log采用段segment的方式来记录，每个undo操作在记录的时候占用一个undo log segment。
● undo log也会产生redo log，因为undo log也要实现持久性保护。


7.4 mysql的二阶段提交
对于Mysql Innodb存储引擎而言，每次修改后，不仅需要记录Redo log还需要记录Binlog，而且这两个操作必须保证同时成功或者同时失败，否则就会造成数据不一致。为此Mysql引入两阶段提交。
